\section {Arhitectura sistemului}

Sistemul prezentat presupune atat o partare hardware, cat si una software. Hardwareul realizeaza adaptarea dintre terminalul analog \acrshort{pots} si placa digitala de dezvoltare Raspberry Pi, iar ca software am folosit NodeJS pentru server si Android pentru a implementa un client al serverului.

Cu ajutorul multimetrului am dedus schema electrica a tastaturii si am gasit contactele care sunt conectate in cazul apasarii butonului de pe ultimul rand, coloana din mijloc. Scurtcircuitarea contactorului lamelar care depisteaza ridicarea receptorului si legarea la difuzorul terminalului au fost realizate mai usor, circuitul fiind usor de parcurs vizual.

\begin{figure}[h!]
  \centering
  \fbox {
    \includegraphics[width=\singlephoto]{04/11_terminal_pots.png}  
  }
  \caption{Depanare si interfatare terminal POTS}
  \medskip
  \small
  1 - contacte buton deschidere, 2 - contactor lamelar receptor, 3 - contacte difuzor
\end{figure}


\subsection {Raspberry Pi HAT}

Dupa ce etapa de prototipare pe breadboard a fost finalizata, am transcris schema electrica a circuitului cu ajutorul softwareul Fritzing. Proiectarea unui 
\acrfull{pcb} reprezinta penultimul pas inainte de etapa de productie in masa. Printre parametrii improtanti in deciderea designului unui circuit printat se numara:

\begin{itemize}
  \item Tehnologia de montare a componentelor pe \acrshort{pcb} (\acrfull{tht} sau \acrfull{smd})
  \item Numarul de straturi de circuit (alegeri comune sunt 2, 4, insa dispozitive complexe precum placile video pot folosi pana la 12 straturi)
  \item Grosimea si culoarea placii de fibra de sticla
  \item Latimea unui traseu pe placa
  \item Distanta minima intre trasee
  \item Diametrul via-urilor (gauri verticale in placa folosite pentru a conecta straturile)
  \item Materialul folosit pentru lipire si meterialul folosit pentru pinii de interfatare
\end{itemize}

Pentru a proiecta un \acrfull{hat} compatibil cu Raspberry Pi, am folosit softwareul Fritzing. Acesta permite proiectarea schemei electrice si ulterior trasarea conexiunilor pe layoutul fizic al placii. Considerand complexitatea redusa a proiectului, am ales sa folosesc doua o placa cu doua straturi, impreuna cu urmatorii parametri pe care i-am introdus in Fritzing ca si constrangeri de design:

\begin{figure}[h!]
  \centering
  \fbox {
    \includegraphics[width=\singlefigure]{04/04_schema_electrica_hut.pdf}  
  }
  \caption{Schema electrica HAT Raspberry PI}
\end{figure}

Actionarea butoanelor terminalului \acrshort{pots} se realizeaza cu ajutorul unor opto-cuploare, izoland circuitul interfonului care este proiectat pentru a functiona cu spike-uri de pana la 90V de circuitul Raspberry Pi.

Detectarea unui apel este realizata prin legarea unui \acrfull{mosfet} la bornele difuzorului terminalului \acrshort{pots} si inserierea cu un amplificator operational in regim de comparator cu referinta de 0.1V. Am folosit de asemenea si un Filtru Trece Jos deoarece terminalul este sensibil la zgomote, declansand accidental notificarea.

\begin{figure}[h!]
  \centering
  \fbox {
    \includegraphics[width=\singlefigure]{04/05_schema_pcb_hut.pdf}  
  }
  \caption{Design \acrshort{pcb} HAT \\(galben - stratul de sus, portocaliu - stratul de jos)}
\end{figure}

\subsubsection {Optocuploare improvizate}

Datorita crizei globale de semiconductori, o placuta breakout care include doua optocuploare costa aproximativ 50 RON. Considerand simplitatea functionarii acestui circuit, am decis sa construiesc propria solutie, folosind componetele de baza: un rezistor pentru limitat curentul, un LED si un fotorezistor. Platforma Raspberry Pi furnizeaza pinilor sai \acrshort{gpio} 3.3V si un curent maxim de 16mA, iar un LED rosu are o cadere de tensiune de 2.4V:

\begin{equation}
\label{eq:test}
\begin{split}
I_{GPIO} & =10\ mA=10^{-2} A\\
V_{R} & =V_{GPIO} -V_{LED} =3.3V-2.4V=0.9V\\
I_{GPIO} & =\frac{V_{R}}{R} \ sau\ R=\frac{V_{R}}{I_{GPIO}} =\frac{0.9V}{10^{-2}A} =90\Omega
\end{split}
\end{equation}

Am lipit rezistorul de 90$\Omega$ la anodul ledului si am incastrat LED-ul impreuna cu fotorezistorul intr-o incinta fara lumina.

\begin{figure}[!ht]
\begin{center}
  \subfloat[Schema optocuplor \cite{OptocouplerCircuitsToday}]{\label{fig:optoa}\includegraphics[width=\doublefigure]{04/01_optocoupler_scheme.jpg}}
  \subfloat[Componenta realizata manual]{\label{fig:optob}\includegraphics[width=\doublefigure]{04/02_optocoupler_assembly.png}}
  \caption{Schema electrica optocuplor (a) si rezultat ansablu (b)}
  \label{fig:opto}
\end{center}
\end{figure}


Deoarece aveam nevoie sa scurtcircuitez un contactor pe partea terminalului \acrshort{pots} am omis rezistenta legata fotorezistorului. Atunci cand ledul este aprins, rezistenta fotorezistorului scade, comportandu-se aproape ca un conductor ideal, atingand lamelele contactorului corespunzator receptorului.

Dupa ce toate traseele au fost plasate, ultimul pas este umplerea spatiului ramas pe fiecare strat cu un plan legat la GND pentru a reduce emisiile electromagnetice. Inainte de a trimite fisierul Gerber spre a fi produs, am folosit constrangerile definite initial pentru a valida proiectul, asigurandu-ne ca acesta poate fi produs in realitate.

\begin{table}[ht!]
\begin{tabular}{llllll}
\hline
Nr. &  &  & Latime & Diametru & Material \\ 
straturi & Tehnologie & Grosime & traseu & via & finisaj \\
\hline
\hline
2 & \acrshort{tht} & 1.6mm & 1mm & 0.5mm & LeadFree HASL-RoHS\\
\hline
\end{tabular}
\centering
\caption{Parametri alesi pentru fabricarea \acrshort{pcb}}
\label{tab:params}
\end{table}

\begin{figure}[!ht]
\begin{center}
  \subfloat[Vedere din fata \acrshort{pcb}]{\label{fig:hata}\includegraphics[width=\doublefigure]{04/06_pcb_front.png}}
  \subfloat[Vedere din spate \acrshort{pcb}]{\label{fig:hatb}\includegraphics[width=\doublefigure]{04/06_pcb_back.png}}
  \caption{Randare placuta inainte de comandat}
  \label{fig:hat}
\end{center}
\end{figure}

\subsection {Webserver NodeJS}

NodeJS este un mediu de rulare JavaScript asincron, cu un design centrat in jurul unei bucle de evenimente. Este proiectat pentru realizarea aplicatiilor scalabile care comunica prin retea. \cite{NodeJs2021}

\begin{figure}[H]
  \centering
  \fbox {
    \includegraphics[width=\singlefigure]{04/12_node_js_system.png}  
  }
  \caption{Ilustrare event loop si callback queue \cite{DevelopPaper2019}}
\end{figure}

Pentru a intelege cum ruleaza codul javascript in acest mediu de rulare, trebuie sa ne familiarizam cu modeul de asincroneitate pus la dispozitie, care difera semnificativ de cel multi-threadded. Codul JavaScript este parcurs cu ajutorul engine-ului V8 si este tradus in apeluri la libraria nativa "libuv" care se va ocupa de executarea lor plasarea in coada de evenimente. Atunci cand "libuv" are nevoie sa faca un apel sincronde sistem, precum interogarea unui server DNS, o face prin intermediul unui thread-pool, atasand un callback pentru a fi chemat atunci cand este gata.

\subsubsection {Criptare HTTPS}

Conform cerintelor functionale, canalul de comunicare dintre client si server trebuie sa fie securizat cu un protocol \acrfull{https} pentru a permite trimiterea credentialelor fara a fi susceptibile la atacuri de tip \acrfull{mitm}. S-a ales folosirea Let's Encrypt, un serviciu gratuit pentru emiterea unui certificat semnat de o autoritate reputabila.

Pentru a verifica identitatea serverului, clientului ii este cerut sa afiseze un sir de date la o ruta statica prestabilita, dovedind astfel autoritate asupra serverului caruia ii va fi emis certificatul. Dupa completarea acesor pasi si emiterea certificatului, configurarea serverului sa implementeze protocolul \acrshort{https} este relativ simpla:

\begin{figure}[H]
  \centering
  \fbox {
    \includegraphics[width=\singlefigure]{04/13_configurare_ssl.png}  
  }
  \caption{Configurare aplicatie NestJs pentru a folosi certificate}
\end{figure}

Este de mentionat ca incepand cu versiunea de Android 9 (Pie) ca parte dintr-o initiativa de marire a securitatii, sistemul de operare va bloca conexiunile PLAINTEXT daca aplicatiile nu configureaza o exceptie pentru server \cite{Digicert2018}. De asemenea, prezentarea unor certiifcate self-signed sau insuficiente informatii vor produce rezultate similare, fiind nevoie ca serverul sa prezinte intregul lant de certificate (al serverului, ale autoritatilor intermediare si in final cel al autoritatii centrale). 

\subsubsection {Autentificare}

Pentru autentificarea si validarea credentialelor utilizatorilor, am ales metoda \acrfull{jwt}, un standard open source in industrie conform RFC 7519. In cea mai compacta forma a sa, acesta este compus din trei parti, despartite prin caracterul ".":

\begin{enumerate}
  \item Header (algoritm si tipul tokenului)
  \item Continut (id utilizator, nume, rol)
  \item Semnatura
\end{enumerate}

Semnatura este calculata cu ajutorul unui algoritm simetric de hashing \acrfull{hs256} si a unei chei private aplicat pe forma codata in baza 64 a continutului si metadatelor despre token (expirare, emitator, audienta, subiect). Toate cele trei informatii sunt apoi concatenate cu caracterul "." intre, constituind forma finala ce va trimisa clientului. Clientul va transmite acest token in comunicatiile ulterioare cu serverul, acesta folosindu-se de mesaj, semnatura si cheia privata pentru a determina daca a fost sau nu modificat pe parcurs.

Folosirea algoritmului simetric implica faptul ca secretul este utilizat atat pentru generarea de tokenuri, cat si pentru validarea lor. In cazul aplicatiei din lucrare, aceasta nu este o problema, deoarece ambele metode ruleaza in interiorul aceluias proces, fara sa expuna aplicatia la vulnerabilitati.

Un avantaj al \acrshort{jwt} este faptul ca serverul nu trebuie sa intretina starea unei tabele de sesiuni a utilizatorilor. In esenta daca un utilizator este in posesia unui token ne-expirat, aceste este considerat autentificat. Prin urmare, mai multe instante ale serverului pot valida in paralel identitatea utilizatorilor, fara nevoia de a interoga o baza de date sau o memorie cache partajata, permitand astfel scalarea pe orizontala a aplicatiei.

\subsubsection {NestJS}

Construit peste cel mai popular framwork pentru aplicatii web disponibil pentru Node.js, NestJS imbunatateste experienta dezvoltarii serviciilor web folosind functii experimentale din Typescript care permit interpretarea la transpilare a decoratorilor pentru metode si clase. De asemenea urmareste un design \acrshort{mvc} si are pachete intretinute oficial pentru taskuri comune, cum ar fi conectarea la o baza de date sau proiectarea unui mecanism de autentificare si verificare a identiatii utilizatorilor.

\subsubsection {Mutex}

Din natura asincrona a limbajului si posibilitatea sistemului de a avea mai mult de un utilizator, trebuie luat in considerare cazul in care mai multi utilizatori incearca sa interactioneze cu sistemul in acelasi timp. Asadar, trebuie implementat un mecanism similar semaforului binar, numit mutex. Diferenta dintre acestea fiind ca in cazul mutexului, doar detinatorul original poate sa il elibereze spre a fi folosit din nou.

Acest comportament este dorit pentru a informa clientii serviciului in cazul in care requestul nu poate fi satisfacut deoarece resursa este ocupata de altcineva.

\begin{figure}[H]
  \centering
  \fbox {
    \includegraphics[width=\singlefigure]{04/03_mutex_diagram.pdf}  
  }
  \caption{Ilustrare resursa disputata intre doi utilizatori}
\end{figure}


\subsubsection {Validarea entitatilor}

Foloseste functii din Typescript si NestJS pentru a adauga si citi metadate prin intermediul decoratorilor de metode. \acrfull{dto} este reprezentarea unui model din baza de date, dar encodat favorbail pentru interpretarea usoara a clientilor. Majoritar, acesta va contine mai putine campuri decat exista in baza de date (reprezentarea unui utilizator nu va avea campul pentru parola).

Campurile unui \acrfull{dto} sunt adnotate cu tipul asteptat la runtime, si printr-un interceptor de nest care ruleaza atunci cand este invocata metoda unui controller \acrshort{rest}, obiectul primit ca parametru este verificat contra specificatiilor din metadate. In cazul in care validarea esueaza, clientului ii este intors status 400 (Bad Request) indicand o eroare de formatare a requestului.

Mutand responsabilitatea verificarii entitatilor in cadrul serverului, se mitigheaza si lipsa unei scheme la nivelul bazei de date, inerente solutiilor NoSQL. Prin urmare se reduce riscul unor inconsistente in datele stocate.

\subsubsection {Roluri}

Urmarind "reteta" de dezvoltare observata in validarea entitatilor, am creat un mecanism de adaugare a metadatelor pe rutele controllerelor despre ce roluri de user au acces sa le cheme.

Partea de verificare a unui user in timpul unui request, revine asa-numitelor "Guard-uri" care implementeaza o interfata comuna. In cazul vederilor pentru aplicatia de admin dormin sa restrictionam afisarea sa userilor normali, asadar inlantuim "Guard-urile" ce garanteaza autentificarea unui utilizator si rolul de administrator. In cazul in care un user nu este administrator, acestuia i se intoarce un cod de status 403 (Forbidden) - serverul a autentificat utilizatorul, dar acesta nu are suficiente permisiuni pentru a accesa resursa

\subsubsection {Documentatie}

Intr-un proiect de lunga durata, documentatia joaca un rol esential in usurinta de mentenanta si dezvoltare a codului. Despartirea logica a componentelor aplicatiei cat si explicarea eventualelor cai logice si raspunsuri posibile ajuta atat clientii externi consumatori ai \acrshort{api}-ului cat si dezvoltatorii noi care incearca sa introduca primele modificari.

Astfel, am ales Swagger pentru a parcurge proiectul si genera pagini de documentatie pentru toate rutele serviciului \acrshort{rest}, impreuna cu comentarii si potentialele status code-uri la care trebuie sa se astepte clientii. De asemenea, Swagger include si un client \acrshort{rest} in pagina, impreuna cu schema obiectelor si tipurile de date asteptate nu lasa loc de interpretat in comportamentul serverului.

\begin{figure}[H]
  \centering
  \fbox {
    \includegraphics[width=\singlephoto]{04/10_swagger_doc.png}  
  }
  \caption{Documentatie generata pentru ruta /users/create}
\end{figure}

\subsection {Android}

Android este o platforma mobila care s-a maturizat pe parcusul a 12 versiuni majore si principalul competitor de piata al iOS. Im dezvoltarea acestei aplicatii am folosit o abordare similara cu cea a serverului, fiind organizata intr-un pattern de design \acrshort{mvc}. O aplicatie Android poate fi alcatuita din mai multe componente cu roluri specifice: Activity, Service si BroadcastReceiver. Fiind un sistem de operare care vizeaza dispozitivele mobile, este optimizat pentru folosirea eficienta a resurselor si a bateriei, astfel ca folosirea incorecta a componentelor anterioare poate duce la oprirea accidentala a aplicatiei sau a unui serviciu in timpul unor operatiuni importante.

O alta particularitate in programarea acestor aplicatii este ca desenatul interfetei si interceptarea evenimentelor de la utilizator se realizeaza intr-o bucla pe firul de executie principal. Astfel, orice operatiuni aditionale executate pe acest thread trebuie alese cu atentie pentru a nu duce la aparenta ingreunare prin introducerea latentei la afisaj si la interpretat evenimente de input de la utilizator. Operatiuni care presupun asteptarea dupa sisteme de \acrshort{io} precum un apel prin retea, sunt complet blocate din a fi executate pe threadul principal, aruncand o exceptie numita "NetworkOnMainThreadException".

\subsubsection {Dependency Injection}

Pentru a gestiona mai usor modulele aplicatiei si diferitele surse de date, am ales sa folosesc Dagger2, un framework bine cunoscut de Java. El vine cu extensii pentru Android ce permit controlul granular asupra instantierii modulelor necesare in functie de ciclul de viata al aplicatiei sau al unui Activity. Astfel putem defini module globale, precum cel care cheama api-ul web, instantiat o singura data pe durata aplicatiei, sau module locale, precum cel de SharedPreferences care se realoca de fiecare data cand se intra in ecranul principal.

Pe langa organizarea proiectului in module logice in functie de functionalitati, Dagger ajuta si la managementul memoriei intr-un limbaj de programare cu Garbage Collector, precum Java, evitand alocari nenecesare sau frecvente.


\section {Implementarea sistemului}

\subsection {Server}

Chiar daca autentificarea prin interfata grafica de administrator beneficiaza de acelasi standard de securitate ca si ceilalti clienti, am ales sa o expun pe un port diferit de cel al \acrshort{api}-ul, permitand flexibilitate maxima utilizatorului final in alegerea expunerii serviciilor. Personal, am expus serviciul de API pe un port rutat public si interfata pe un port privat, blocat din firewall. In esenta, orice utilizator normal poate interactiona cu sistemul atata timp cat este autentificat, insa interfata de administrare este disponibila doar din interiorul retelei din acasa.

\begin{figure}[h!]
  \centering
  \fbox {
    \includegraphics[width=\singlelongfigure]{04/09_serviciu_intercom.png}  
  }
  \caption{Implementarea metodei pentru permis accesul din IntercomService}
\end{figure}

Secventa de generare a comenzilor pentru deschiderea interfonului se afla in clasa IntercomService, aceasta secventa include: obtinerea mutexului, ridicarea receptorului, asteptarea pentru o secunda, apasarea butonului pentru raspuns de doua ori, cu o pauza de 1.2s intre si in final eliberarea mutexului. Secventa pentru respingerea unui apel a fost implementata intr-o maniera similara, presupunand doar ridicarea receptorului si inchiderea sa dupa un interval arbitrar de timp.

\subsection {Baza de date}

\begin{figure}[h!]
  \centering
  \fbox {
    \includegraphics[width=\singlelongfigure]{04/08_schema_db.png}  
  }
  \caption{Schema bazei de date Mongo}
\end{figure}

Baza de date nu ofera nicio relatie intre documente, insa colectia "logs" sau "autoanswerstatuses" trebuie sa fie legate din punct de federe logic cu un utilizator. Putem din nou sa beneficiem de adnotari, specificand tipul asteptat pentru validare sau o referinta catre o alta colectie.

Salvam astfel id-ul utilizatorului care le-a generat impreuna cu ele, iar la momentul interogarii bazei de date putem folosi metoda "populate()" din driverul Mongoose care va cauta modelul pentru adnotari de tip referinta. In final, driverul va genera query-uri pentru a aduce "referintele" din colectiile corespunzatoare. Daca o referinta nu este gasita, se va intoarce "null" si este responsabilitatea aplicatiei sa trateze acest caz. 

\subsection {Aplicatie mobila}

Pentru a evita complet problema rularii apelurilor de retea pe threadul gresit, am folosit un client \acrshort{rest} numit Retrofit, bazat pe OkHttp. Aceasta se ocupa sa coordoneze un ThreadPool (o colectie de threaduri ce executa taskuri de acelasi tip), astfel ca atunci cand aplicatia cheama un serviciu, se alege unul din threaduri spre a se executa cererea, raspunsul venind sub forma unui callback pe threadul principal.

\begin{figure}[H]
  \centering
  \fbox {
    \includegraphics[width=\singlefigure]{04/14_di_network_module.png}  
  }
  \caption{Configurare modul retea, impreuna cu dependintele sale directe}
\end{figure}

Datorita adnotarilor @Singleton toate obiectele din acest modul vor fi instantiate o singura data pe durata aplicatiei, oferind un punct de acces centralizat pentru toate operatiile ce implica chemarea serviciilor \acrshort{rest}.

De asemenea, am configurat Retrofit sa foloseasca Gson pentru serializarea si deserializarea \acrshort{dto}-urilor din format \acrshort{json} in instante ale claselor din Java. Pentru aceasta operatiune se foloseste de \acrshort{api}-ul reflectiv oferit de limbajul Java spre a chema constructorul implicit al unei clase si a seta valorile variabilelor sale.

\section {Testarea sistemului}

\subsection {Server}

Chiar daca NestJS ofera suport pentru scrierea de teste unitare prin adaugarea de fisere $.spec.ts$, cea mai mare provocare a fost mockuirea modulului care comunica cu pinii \acrshort{gpio} ai Raspberry Pi. Wrapperul de JavaScript comunica prin intermediul \acrfull{napi} cu o librarie statica ce realizeaza serializarea si deserializarea datelor dintre Node.js/V8 VM si C/C++. Aceasta librarie se linkeaza la randul ei cu $bcm2835$ pentru a obtine acces la pinii \acrshort{gpio} si alte functii din sistemul de \acrfull{io} al cipului Broadcom 2835.

Astfel suntem prezentati cu o problema, libraria \acrshort{napi} poate fi compilata pe alte arhitecturi, dar cu siguranta va genera o exceptie la rulare cand dependinta sa, $bcm2835$, va incerca sa execute instructiuni invalide. Este nevoie de o logica de control care sa permita rularea si returnarea unor date prestabilite, cand se detecteaza rularea pe o arhitectura invalida, cum ar fi in cazul testelor rulate in mod automat prin intermediul pipelineului de integrare continua.

\subsubsection {Teste unitare}

Urmatorul pas a fost elaborarea testelor unitare. Am ales sa creez un fisier $.spec.ts$ pentru fiecare controller al API-ului acoperind astfel intreaga functionalitate a aplicatiei. Pentru controllerului responsabil deschiderii interfonului am mockuit serviciile Firebase si baza de date, testand mecanismul de deschidere/inchidere a interfonului in cazul in care aceeasi resursa este accesata de mai multi utilizatori concomitent.

\subsubsection {Teste end-to-end}

Pentru a ne asigura ca serviciul \acrshort{rest} raspunde corect se impune necesitatea testelor cap coada, unde se instantiaza aplicatia intr-o maniera similara productiei, iar cu ajutorul unui client rest se trimit cereri prestabilite si se asteapta dupa raspunsurile lor. Astfel parcurgem toata logica serverului, cap-coada si ne vom asigura de un comportament predictibil.

\subsection {Aplicatie mobila}

Din cauza fragmentarii foarte mari a versiunilor si configuratiilor posibile pentru toate dispozitivele Android pe care ar putea rula aplicatia, am decis sa folosesc "Firebase Test Lab", un serviciu de la Google care ofera posibilitatea rularii unui test automat sau scriptat pe o gama larga de dispozitive. 
Asiguram astfel un minim control al calitatii prin descoperirea timpurie a exceptiilor netratate.

Tipul de test ales este cel "Robo", care va analizeaza inteligent interfata vizuala a aplicatiei, dupa care va genera evenimente de input ca si cum ar fi un utilizator. Planul "Spark" de la Firebase ne da acces la 5 rulari pe dispozitive fizice pe zi si 10 dispozitive virtuale, deci testele au fost executate in limita acestor constrangeri. 

Pentru a rula un testa, trebuie sa incarcam un APK sau un AAB, alegem dispozitivele pe care dorim sa testam si eventualii pasi aditionali pe care ii dorim acoperiti de Robo. Dupa introducerea id-ului pentru campurile de username si parola impreuna cu valorile asociate unui cont de test, a reusit sa se autentifice si sa faca un stress-test al aplicatiei. Urmatoarele dispozitive de test au fost alese:

\begin{itemize}
  \item SM-F926U1, API Level 30 - telefon pliabil, care prezinta o dimensiune non-standard si provocari unice in ceea ce priveste adaptearea intefetelor pentru o experienta cat mai placuta
  \item Nexus 5, API Level 23 - versiune mai veche, dar foarte populara de Android, rezolutie standard FullHD, acest test se asigura ca aplicatia este compatibila cu versiuni anterioare ale sistemului de operare
  \item SM-T720, API Level 28 - tableta, ne asiguram ca aplicatia este folosibila pe un ecran cu diagonala mare
\end{itemize}

Analizand tabelul pentru performanta vizuala, observam ca aplicatia ruleaza in margini acceptabile pana si pe un dispozitiv mai vechi precum Nexus 5.

\begin{table}[ht!]
\begin{tabular}{ll}
\hline
Metrica &  Valoare \\ 
\hline
\hline
Druata pana la prima afisare & 700ms \\
Eveniment VSync Pierdut & 3\% \\
Latenta ridicata input & 0\% \\
Thread UI incet & 4\% \\
Comanda draw inceata & 1\% \\
Incarcare bitmap inceata & 0\% \\
\hline
\end{tabular}
\centering
\caption{Metrice de performanta raportate penetru Nexus 5}
\label{tab:metrics}
\end{table}

De asemenea "Test Lab" poate fi chemat din interiorul pipelineul de integrare continua pentru a rula teste automat dupa terminarea unui build pe un anumit branch, verificand flow-uri exesitente din aplicatie impotriva potentialelor regresii aparute.

\begin{figure}[h!]
  \centering
  \fbox {
    \includegraphics[width=\singlefigure]{04/07_test_lab.png}  
  }
  \caption{Flow testare Robo pe Samsung SM-F926U1}
\end{figure}